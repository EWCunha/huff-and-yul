


/* Imports */
#include "../lib/huffmate/src/data-structures/Hashmap.huff"

/* interface */
#define function transfer(address,uint256) nonpayable returns(bool)
#define function transferFrom(address,address,uint256) nonpayable returns(bool)
#define function approve(address,uint256) nonpayable returns(bool)
#define function name() nonpayable returns(string)
#define function symbol() nonpayable returns(string)
#define function decimals() nonpayable returns(uint256)
#define function totalSupply() nonpayable returns(uint256)
#define function balanceOf(address) nonpayable returns(uint256)
#define function allowance(address,address) nonpayable returns(uint256)

#define event Transfer(address indexed, address indexed, uint256)
#define event Approval(address indexed, address indexed, uint256)

#define function Error(string) nonpayable returns()

// Storage slot
#define constant NAME_SLOT = FREE_STORAGE_POINTER()
#define constant SYMBOL_SLOT = FREE_STORAGE_POINTER()
#define constant DECIMALS_SLOT = FREE_STORAGE_POINTER()
#define constant TOTAL_SUPPLY_SLOT = FREE_STORAGE_POINTER()
#define constant BALANCE_OF_SLOT = FREE_STORAGE_POINTER()
#define constant ALLOWANCE_SLOT = FREE_STORAGE_POINTER()

#define macro GET_NAME() = takes(0) returns(0) {
    [NAME_SLOT] sload // [name]

    // checking if long length string
    dup1 // [name, name]
    0x01 // [0x01, name, name]
    and // [long_length_id, name, name]
    0x01 // [0x01, long_length_id, name, name]
    eq // [is_long_length==true, name]
    nameLongLength jumpi // [2*name_length+1]

    // returning name
    dup1 // [name, name]
    0xFF and // [2*name_length, name]
    0x02 // [2, 2*name_length, name]
    swap1 // [2*name_length, 2, name]
    div // [name_length, name]
    0x20 0x00 mstore // Memory: offset stack: [name_length, name]
    0x20 mstore // Memory: offsetname_length stack: [name]
    0x40 mstore // Memory: offsetname_lengthname stack: []
    0x60 0x00 return

    nameLongLength:
        0x01  // [1, 2*name_length+1]
        swap1 sub // [2*name_length]
        0x02 // [2, 2*name_length]
        swap1 div // [name_length]

        [NAME_SLOT] 0x00 mstore // Memory: name.slot stack: [name_length]
        0x20 0x00 sha3 // [ptr, name_length]

        sload // [name, name_length]
        0x00 mstore // Memory: name stack: [name_length]

        0x60 0x00 return
}

#define macro GET_SYMBOL() = takes(0) returns(0) {
    [SYMBOL_SLOT] sload // [symbol]

    // checking if long length string
    dup1 // [symbol, symbol]
    0x01 // [0x01, symbol, symbol]
    and // [long_length_id, symbol, symbol]
    0x01 // [0x01, long_length_id, symbol, symbol]
    eq // [is_long_length==true, symbol]
    symbolLongLength jumpi // [2*symbol_length+1]

    // returning symbol
    dup1 // [symbol, symbol]
    0xFF and // [2*symbol_length, symbol]
    0x02 // [2, 2*symbol_length, symbol]
    swap1 // [2*symbol_length, 2, symbol]
    div // [symbol_length, symbol]
    0x20 0x00 mstore // Memory: offset stack: [symbol_length, symbol]
    0x20 mstore // Memory: offsetsymbol_length stack: [symbol]
    0x40 mstore // Memory: offsetsymbol_lengthsymbol stack: []
    0x60 0x00 return

    symbolLongLength:
        0x01  // [1, 2*symbol_length+1]
        swap1 sub // [2*symbol_length]
        0x02 // [2, 2*symbol_length]
        swap1 div // [symbol_length]

        [SYMBOL_SLOT] 0x00 mstore // Memory: symbol.slot stack: [symbol_length]
        0x20 0x00 sha3 // [ptr, symbol_length]

        sload // [symbol, symbol_length]
        0x00 mstore // Memory: symbol stack: [symbol_length]

        0x60 0x00 return
}

#define macro GET_DECIMALS() = takes(0) returns(0) {
    [DECIMALS_SLOT] sload // [decimals]
    0x00 mstore // Memory: decimals stack: []
    0x20 0x00 return
}

#define macro GET_TOTAL_SUPPLY() = takes(0) returns(0) {
    [TOTAL_SUPPLY_SLOT] sload // [totalSupply]
    0x00 mstore // Memory: totalSupply stack: []
    0x20 0x00 return
}

#define macro GET_ALLOWANCE() = takes(0) returns(0) {   
    0x24 calldataload // [spender]
    0x04 calldataload // [user, spender]
    [ALLOWANCE_SLOT] // [allowance.slot, user, spender]
    LOAD_ELEMENT_FROM_KEYS_2D(0x00) // [allowance[user][spender]]

    0x00 mstore // Memory: allowance[user][spender] stack: []
    0x20 0x00 return
}

#define macro GET_BALANCE_OF() = takes(0) returns(0) {
    0x04 calldataload // [user]
    [BALANCE_OF_SLOT] // [balanceOf.slot, user]
    LOAD_ELEMENT_FROM_KEYS(0x00) // [balanceOf[user]]

    0x00 mstore // Memory: balanceOf[user] stack: []
    0x20 0x00 return
}

#define macro TRANSFER() = takes(0) returns(0) {
    0x04 calldataload // [to]
    0x24 calldataload // [amount, to]
    dup1 // [amount, amount, to]

    caller [BALANCE_OF_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00) // [balance, amount, amount, to]     
    dup2 dup2 lt revertTransfer jumpi // [balance, amount, amount, to]

    sub caller [BALANCE_OF_SLOT]  // [balanceOf.slot, msg.sender, balance - amount, amount, to]
    STORE_ELEMENT_FROM_KEYS(0x00) // [amount, to]
    dup1 dup3 [BALANCE_OF_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00) // [toAmount, amount, amount, to]
    add dup3 [BALANCE_OF_SLOT] STORE_ELEMENT_FROM_KEYS(0x00) // [amount, to]
    0x00 mstore // Memory: amount stack: [to]
    caller __EVENT_HASH(Transfer) 0x20 0x00  // Memory: amount stack: [offset, size, transfer_topic, msg.sender, to]   
    log3 // []

    0x01 0x00 mstore // []
    0x20 0x00 return // []

    revertTransfer:
        __FUNC_SIG(Error) 0xE0 shl 0x00 // [0x00, "Error(string)" sig, amount, to]
        mstore // Memory: "Error(string)" sig stack: [amount, to]
        0x20 0x04 // Memory: "Error(string)" sig stack: [0x04, 0x20, amount, to]
        mstore // Memory: "Error(string)" sig00...20 stack: [amount, to]
        0x12 0x24 // [0x24, 0x12, amount, to]
        mstore // Memory: "Error(string)" sig00...20000...012 stack: [amount, to]
        __RIGHTPAD(0x6e6f7420656e6f7567682062616c616e6365) 0x44 // [0x44, "not enough balance", amount, to]
        mstore // Memory: Error(string)" sig00...20000...012000..."not enough balance" stack: [amount, to]
        0x64 0x00 revert // [amount, to]

}

#define macro CONSTRUCTOR() = takes(0) returns(0) {
    // load decimals into memory
    0x20 // [size]
    0xC0 codesize sub // [offset, size]
    0x00 // [mem_dest, offset, size]
    codecopy  // Memory: decimals stack: []

    // store decimals in storage
    0x00 mload // [decimals]
    [DECIMALS_SLOT] sstore // []
    
    // load totalSupply into memory
    0x20 // [size]
    0xA0 codesize sub // [offset, size]
    0x00 // [mem_dest, offset, size]
    codecopy // Memory: totalSupply stack: []

    // load totalSupply into stack and duplicate it (to store in caller's balance)
    0x00 mload // [totalSupply]
    dup1 // [totalSupply, totalSupply]
    
    // store totalSupply into storage
    [TOTAL_SUPPLY_SLOT] sstore // [totalSupply]

    // store totalSupply in caller's balance
    caller // [msg.sender, totalSupply]
    [BALANCE_OF_SLOT] // [balanceOf.slot, msg.sender, totalSupply]
    STORE_ELEMENT_FROM_KEYS(0x00) // []

    // load name offset into stack    
    0x100 codesize sub // [offset]
    0x20 // [size, offset]
    dup2 // [offset, size, offset]
    0x00 // [mem_dest, offset, size, offset]
    codecopy // Memory: name_offset stack: [offset]
    0x00 mload // [name_offset, offset]
     
    // load name length into stack
    0x20 // [size, name_offset, offset]  
    dup3 // [offset, size, name_offset, offset]  
    dup3 // [name_offset, offset, size, name_offset, offset]
    add  // [name_length_offset, size, name_offset, offset]
    0x00 // [mem_dest, name_lengh_offset, size, name_offset, offset]    
    codecopy //; Memory: name_length stack: [name_offset, offset]
    0x00 mload // [name_length, name_offset, offset]

    // check name length
    0x19 // [31 bytes, name_length, name_offset, offset]
    dup2 // [name_length, 31 bytes, name_length, name_offset, offset]
    gt // [name_length > 31 bytes, name_length, name_offset, offset]
    nameBigLength jumpi // [name_length, name_offset, offset]

    // load name into stack
    swap1 // [name_offset, name_length, offset]
    dup3 // [offset, name_offset, name_length, offset]
    add // [offset + name_offset, name_length, offset]
    0x20 // [size, offset + name_offset, name_length, offset]
    swap1 // [offset + name_offset, size, name_length, offset]
    0x20  // [length_offset, offset + name_offset, size, name_length, offset]
    add // [length_offset + offset + name_offset, size, name_length, offset]
    0x00 // [mem_dest, length_offset + offset + name_offset, size, name_length, offset]    
    codecopy // Memory: name stack: [name_length, offset]
    0x00 mload // [name, name_length, offset]

    // store name in storage (if length < 32 bytes)
    swap1 // [name_length, name, offset]
    0x02 mul // [2*name_length, name, offset]
    or // ["name"lengh]
    [NAME_SLOT] sstore // []
    symbolStore jump // []

    nameBigLength:
        // store 2*length+1 in storage
        dup1 // [name_length, name_length, name_offset, offset]
        0x02 mul 0x01 add // [2*name_length+1, name_length, name_offset, offset]
        [NAME_SLOT] sstore // [name_length, name_offset, offset]

        // loop
        [NAME_SLOT] 0x00 mstore // Memory: name.slot stack: [name_length, name_offset, offset]
        0x20 0x00 sha3  // Memory: name.slot stack: [ptr, name_length, name_offset, offset]
        swap1 // [name_length, ptr, name_offset, offset]
        0x00 // [i, name_length, ptr, name_offset, offset]
        nameLoop: 
            dup2  // [name_length, i, name_length, ptr, name_offset, offset]
            dup2  // [i, name_length, i, name_length, ptr, name_offset, offset]
            lt not // [!(i < name_length), i, name_length, ptr, name_offset, offset]
            symbolStore jumpi // [i, name_length, ptr, name_offset, offset]

            dup1  // [i, i, name_length, ptr, name_offset, offset]            
            0x01 add // [i+1, i, name_length, ptr, name_offset, offset]
            0x20 mul // [32*(i+1), i, name_length, ptr, name_offset, offset]
            dup5  // [name_offset, 32*(i+1), i, name_length, ptr, name_offset, offset]
            add  // [name_offset + 32*(i+1), i, name_length, ptr, name_offset, offset]
            mload // [name_part, i, name_length, ptr, name_offset, offset]
            dup4 // [ptr, name_part, i, name_length, ptr, name_offset, offset]
            dup3 // [i, ptr, name_part, i, name_length, ptr, name_offset, offset]
            add // [ptr+i, name_part, i, name_length, ptr, name_offset, offset]
            sstore // [i, name_length, ptr, name_offset, offset]

            nameLoop jump // [i, name_length, ptr, name_offset, offset]
        

    symbolStore:
        // load symbol offset into stack    
        0xE0 codesize sub // [offset]
        0x20 // [size, offset]
        dup2 // [offset, size, offset]
        0x00 // [mem_dest, offset, size, offset]
        codecopy // Memory: symbol_offset stack: [offset]
        0x00 mload // [symbol_offset, offset]
        
        // load symbol length into stack
        0x20 // [size, symbol_offset, offset]  
        0x100 codesize sub // [constructor_args_offset, size, symbol_offset, offset]  
        dup3 // [symbol_offset, constructor_args_offset, size, symbol_offset, offset]
        add  // [symbol_length_offset, size, symbol_offset, offset]
        0x00 // [mem_dest, symbol_lengh_offset, size, symbol_offset, offset]    
        codecopy //; Memory: symbol_length stack: [symbol_offset, offset]
        0x00 mload // [symbol_length, symbol_offset, offset]

        // check symbol length
        0x19 // [31 bytes, symbol_length, symbol_offset, offset]
        dup2 // [symbol_length, 31 bytes, symbol_length, symbol_offset, offset]
        gt // [symbol_length > 31 bytes, symbol_length, symbol_offset, offset]
        symbolBigLength jumpi // [symbol_length, symbol_offset, offset]

        // load symbol into stack
        swap1 // [symbol_offset, symbol_length, offset]
        0x100 codesize sub // [constructor_args_offset, symbol_offset, symbol_length, offset]
        add // [constructor_args_offset + symbol_offset, symbol_length, offset]
        0x20 // [size, offset + symbol_offset, symbol_length, offset]
        swap1 // [offset + symbol_offset, size, symbol_length, offset]
        0x20  // [length_offset, offset + symbol_offset, size, symbol_length, offset]
        add // [length_offset + offset + symbol_offset, size, symbol_length, offset]
        0x00 // [mem_dest, length_offset + offset + symbol_offset, size, symbol_length, offset]    
        codecopy // Memory: symbol stack: [symbol_length, offset]
        0x00 mload // [symbol, symbol_length, offset]

        // store symbol in storage (if length < 32 bytes)
        swap1 // [symbol_length, symbol, offset]
        0x02 mul // [2*symbol_length, symbol, offset]
        or // ["symbol"lengh]
        [SYMBOL_SLOT] sstore // []
        final jump

    symbolBigLength:
        // store 2*length+1 in storage
        dup1 // [symbol_length, symbol_length, symbol_offset, offset]
        0x02 mul 0x01 add // [2*symbol_length+1, symbol_length, symbol_offset, offset]
        [SYMBOL_SLOT] sstore // [symbol_length, symbol_offset, offset]

        // loop
        [SYMBOL_SLOT] 0x00 mstore // Memory: symbol.slot stack: [symbol_length, symbol_offset, offset]
        0x20 0x00 sha3  // Memory: symbol.slot stack: [ptr, symbol_length, symbol_offset, offset]
        swap1 // [symbol_length, ptr, symbol_offset, offset]
        0x00 // [i, symbol_length, ptr, symbol_offset, offset]
        symbolLoop: 
            dup2  // [symbol_length, i, symbol_length, ptr, symbol_offset, offset]
            dup2  // [i, symbol_length, i, symbol_length, ptr, symbol_offset, offset]
            lt not // [!(i < symbol_length), i, symbol_length, ptr, symbol_offset, offset]
            final jumpi // [i, symbol_length, ptr, symbol_offset, offset]

            dup1  // [i, i, symbol_length, ptr, symbol_offset, offset]            
            0x01 add // [i+1, i, symbol_length, ptr, symbol_offset, offset]
            0x20 mul // [32*(i+1), i, symbol_length, ptr, symbol_offset, offset]
            dup5  // [symbol_offset, 32*(i+1), i, symbol_length, ptr, symbol_offset, offset]
            add  // [symbol_offset + 32*(i+1), i, symbol_length, ptr, symbol_offset, offset]
            mload // [symbol_part, i, symbol_length, ptr, symbol_offset, offset]
            dup4 // [ptr, symbol_part, i, symbol_length, ptr, symbol_offset, offset]
            dup3 // [i, ptr, symbol_part, i, symbol_length, ptr, symbol_offset, offset]
            add // [ptr+i, symbol_part, i, symbol_length, ptr, symbol_offset, offset]
            sstore // [i, symbol_length, ptr, symbol_offset, offset]

            symbolLoop jump // [i, symbol_length, ptr, symbol_offset, offset]

    final:
}

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xE0 shr // [function_selector]

    dup1 __FUNC_SIG(transfer) eq transferDest jumpi
    dup1 __FUNC_SIG(transferFrom) eq transferFromDest jumpi
    dup1 __FUNC_SIG(approve) eq approveDest jumpi
    dup1 __FUNC_SIG(name) eq nameDest jumpi
    dup1 __FUNC_SIG(symbol) eq symbolDest jumpi
    dup1 __FUNC_SIG(decimals) eq decimalsDest jumpi
    dup1 __FUNC_SIG(totalSupply) eq totalSupplyDest jumpi
    dup1 __FUNC_SIG(balanceOf) eq balanceOfDest jumpi
    __FUNC_SIG(allowance) eq allowanceDest jumpi

    0x00 0x00 revert

    transferDest:
        TRANSFER()

    transferFromDest:
    // macro

    approveDest:
    // macro

    nameDest:
        GET_NAME()

    symbolDest:
        GET_SYMBOL()

    decimalsDest:
        GET_DECIMALS()

    totalSupplyDest:
        GET_TOTAL_SUPPLY()

    balanceOfDest:
        GET_BALANCE_OF()

    allowanceDest:
        GET_ALLOWANCE()
}